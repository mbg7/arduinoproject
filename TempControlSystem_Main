/* ******************************************************************************
tempController.ino : This function is the setup & loop of the Temp Control System. 
1st, It calls files from DisplayFunctions.ino, HeaterControl.ino, and SetTemp.
2nd, prompts the user to adjust the set point of the temperature controller. 
3rd, uses a PID control system to reach and maintain the set temperature in the output.
If the maxTemp is exceeded, the screen locks out with a warning and the output 
    is locked to off position, with the PID blocked off.  To recover from an 
    overTempAlarm state, the user must reset the controller.
Future functionality: 
      (1) Improve PID using AutoTune
      (2) Set alarm lock if the heater has beeen on for too long 
          > because if physical thermocouple fails, currentTemp is unreliable.
      (3) Other safety features
******************************************************************************** */
#include <PID_v1.h>
#include <LiquidCrystal.h>
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

// Define Global Variables
double T0 = 0;
double desiredTemp = 0;
double desiredTime = 0;
// double desiredTemp1 = 0;
// double desiredTemp2 = 0;
// double desiredTemp3 = 0;
// double desiredTime1 = 0;
// double desiredTime2 = 0;
// double desiredTime3 = 0;
double currentTemp = 0; //analog input converted to degrees 
double setTemp = 0; //user input. The desired temperature of the oven. 
double maxTemp = 270; // Max allowed temp. Signal alarm if temp ever exceeds this.
double minTemp = 25; // Room temperature
boolean desiredTempSet = false; // Has the desired temp been set yet?
boolean desiredTimeSet = false; // Has the desired time been set yet?
boolean OverTempAlarm = false;
int readTempPin = A5; //Analog input from pin A5
int heaterPin = 2; //Digital output to pin D3, a PWM pin

// Specify PID parameters and variables
double kp = 2; //(proportional gain - difference between the current temperature and the set point)
double ki = 0.1; //(integral gain - proportional to the magnitude and duration of error)
double kd = 5; //(derivative gain - slope of the error over time)
double Output;
int WindowSize = 50; //ms
unsigned long windowStartTime;
PID myPID(&currentTemp, &Output, &setTemp,kp,ki,kd,DIRECT);

void setup()
{
  Serial.begin(9600);
  lcd.begin(16,2);
  pinMode(readTempPin, INPUT);
  pinMode(heaterPin, OUTPUT);
  windowStartTime = millis();
  myPID.SetOutputLimits(0, WindowSize); // tell the PID to range
        // between 0 (never on) and 50 ms (always on)
  myPID.SetMode(AUTOMATIC);
}

void loop()
{
  if(!OverTempAlarm){ // As long as we are not overheated...
      while(!desiredTempSet){ // Set the desired temps and times if you haven't already.  This should only be done once per reset.
        display_instructions);
        double desiredTemp1 = setDesiredTemp();
        double desiredTime1 = setDesiredTime();
        double desiredTemp2 = setDesiredTemp();
        double desiredTime2 = setDesiredTime();
        double desiredTemp3 = setDesiredTemp();
        double desiredTime2 = setDesiredTime();
        desiredTempSet = true; // The user has set all their desired values.  We don't need to run these commands again.
      }

        double startTime= millis();
        double val0=analogRead(readTempPin); //reading from thermocouple pin at start of reflow
        double volt0=(val0/1023)*5; //map that reading to a voltage 
        T0=volt0/(0.005); // Temperature at the start of the reflow 
      
**********************CHUNK OF CODE TO DETERMINE WHAT REFLOW SECTION WE ARE IN******************************

      PIDHeaterControl(); //Monitor & control the temp
  }
}

